// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

// Author: @andrewkimjoseph

contract ClosedSurveyV4 is Ownable, ReentrancyGuard, Pausable {
    using ECDSA for bytes32;

    IERC20Metadata public immutable cUSD;

    mapping(address => bool) private rewardedParticipants;
    mapping(address => bool) private participantsScreenedForSurvey;
    mapping(bytes => bool) private signaturesUsedForClaiming;

    uint256 public rewardAmountPerParticipantInWei;
    uint256 public targetNumberOfParticipants;
    uint256 private numberOfRewardedParticipants;
    uint256 private numberOfClaimedRewards;

    uint256 public numberOfScreenedParticipants;
    uint256 public numberOfUsedSignatures;

    event ParticipantScreened(address participant);

    /**
     * @notice Emitted when a participant successfully claims their reward
     * @param participant The address of the rewarded participant
     * @param rewardAmount The amount of cUSD rewarded in wei
     */
    event ParticipantRewarded(address participant, uint256 rewardAmount);
    event SignatureUsed(bytes signature, address participant);

    event ParticipantMarkedAsRewarded(address participant);

    event RewardFundsWithdrawn(address researcher, uint256 rewardAmount);

    event RewardAmountUpdated(
        uint256 oldcUSDRewardAmountPerParticipantInWei,
        uint256 newcUSDRewardAmountPerParticipantInWei
    );

    event TargetNumberOfParticipantsUpdated(
        uint256 oldTargetNumberOfParticipants,
        uint256 newTargetNumberOfParticipants
    );

    /**
     * @dev Verifies that the signature provided matches the participant's data and was signed by the contract owner
     * @param participant - The wallet address of the participant claiming the reward
     * @param rewardId - Unique identifier for this reward claim
     * @param nonce - Unique number, timestamp in nanoseconds to prevent relay attacks
     * @param signature - Cryptographic signature generated by the contract owner
     */
    modifier onlyIfGivenSignatureIsValid(
        address participant,
        string memory rewardId,
        uint256 nonce,
        bytes memory signature
    ) {
        require(
            verifySignature(participant, rewardId, nonce, signature),
            "Invalid signature"
        );
        _;
    }

    /**
     * @dev Ensures a signature hasn't been used before to prevent replay attacks
     * @param signature - The cryptographic signature to check
     */
    modifier onlyIfGivenSignatureIsUnused(bytes memory signature) {
        require(
            !signaturesUsedForClaiming[signature],
            "Signature already used"
        );
        _;
    }

    /**
     * @dev Ensures participant hasn't been screened yet
     * @param participant - Address of the participant to check
     */
    modifier onlyUnscreenedParticipant(address participant) {
        require(
            !participantsScreenedForSurvey[participant],
            "Only unscreened address"
        );
        _;
    }

    /**
     * @dev Throws if called for a [participant] that is unscreened.
     */
    modifier mustBeScreened(address participant) {
        require(participantsScreenedForSurvey[participant], "Must be screened");
        _;
    }

    /**
     * @dev Throws if called for a [participant] that is rewarded.
     */
    modifier onlyUnrewardedParticipant(address participant) {
        require(
            !rewardedParticipants[participant],
            "Participant already rewarded"
        );
        _;
    }

    /**
     * @dev Throws if called for a [participant] that is not the [msg.sender].
     */
    modifier onlyIfSenderIsGivenParticipant(address participant) {
        require(msg.sender == participant, "Only valid sender");
        _;
    }

    /**
     * @dev Throws if called when [cUSD.balanceOf(address(this))] is < [rewardAmountPerParticipantInWei]
     */
    modifier onlyIfContractHasEnoughcUSD() {
        require(
            cUSD.balanceOf(address(this)) >= rewardAmountPerParticipantInWei,
            "Contract does not have enough cUSD"
        );
        _;
    }

    /**
     * @dev Throws if called when [cUSD.balanceOf(address(this))] is == 0.
     */
    modifier onlyIfContractHasAnycUSD() {
        require(
            cUSD.balanceOf(address(this)) > 0,
            "Contract does not have any cUSD"
        );
        _;
    }

    /**
     * @dev Throws if called when all participants have been rewarded.
     */
    modifier onlyWhenAllParticipantsHaveNotBeenRewarded() {
        require(
            numberOfRewardedParticipants < targetNumberOfParticipants,
            "All participants have been rewarded"
        );
        _;
    }

    /**
     * @notice Initializes the survey contract with initial parameters
     * @dev Sets up the contract with researcher address, reward amount, participant target, and cUSD token
     * @param researcher - Address of the researcher who will own and manage the contract
     * @param _rewardAmountPerParticipantInWei - Amount in wei to reward each participant
     * @param _targetNumberOfParticipants - Maximum number of participants for the survey
     * @param cUSDToken - Address of the cUSD token contract
     */
    constructor(
        address researcher,
        uint256 _rewardAmountPerParticipantInWei,
        uint256 _targetNumberOfParticipants,
        address cUSDToken
    ) Ownable(researcher) {
        require(cUSDToken != address(0), "Zero address given for cUSD Token");

        require(researcher != address(0), "Zero address given for researcher");

        require(_rewardAmountPerParticipantInWei > 0, "Invalid reward amount");

        require(
            _targetNumberOfParticipants > 0,
            "Invalid number of target participants"
        );

        cUSD = IERC20Metadata(cUSDToken);

        rewardAmountPerParticipantInWei = _rewardAmountPerParticipantInWei;
        targetNumberOfParticipants = _targetNumberOfParticipants;
    }

    /**
     * @dev Marks a [participant] as [true] in [participantsScreenedForSurvey].
     */
    function screenParticipant(address participant)
        external
        onlyIfSenderIsGivenParticipant(participant)
        onlyUnscreenedParticipant(participant)
    {
        require(participant != address(0), "Zero address passed");

        participantsScreenedForSurvey[participant] = true;
        unchecked {
            ++numberOfScreenedParticipants;
        }
        emit ParticipantScreened(participant);
    }

    /**
     * @dev Gets the message hash that will be signed by the contract owner
     * @param participant The wallet address of the participant claiming the reward
     * @param rewardId A unique identifier for this specific reward claim
     * @param nonce - Unique number, timestamp in nanoseconds to prevent relay attacks
     * @return bytes32 The keccak256 hash of the packed parameters
     *
     * The hash is created by tightly packing the parameters in order:
     * 1. participant - address
     * 2. rewardId - string
     * 3. nonce - Unique number, timestamp in nanoseconds to prevent relay attacks
     *
     * This hash must match exactly what is signed off-chain by the contract owner
     */
    function getMessageHash(
        address participant,
        string memory rewardId,
        uint256 nonce
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(participant, rewardId, nonce));
    }

    /**
     * @dev Verifies that a signature is valid for given participant data
     * @param participant - Address of the participant claiming the reward
     * @param rewardId - Unique identifier for this reward claim
     * @param nonce - Unique number, timestamp in nanoseconds to prevent relay attacks
     * @param signature - Cryptographic signature to verify
     * @return bool - True if signature is valid, false otherwise
     */
    function verifySignature(
        address participant,
        string memory rewardId,
        uint256 nonce,
        bytes memory signature
    ) private view returns (bool) {
        bytes32 messageHash = getMessageHash(participant, rewardId, nonce);
        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(
            messageHash
        );
        return ethSignedMessageHash.recover(signature) == owner();
    }

    /**
     * @notice Allows a participant to claim their reward using a valid signature
     * @dev Processes the reward claim if all conditions are met and signature is valid
     * @param participant - Address of the participant claiming the reward
     * @param rewardId - Unique identifier for this reward claim
     * @param nonce - Unique number, timestamp in nanoseconds to prevent relay attacks
     * @param signature - Cryptographic signature from the contract owner
     */
    function processRewardClaimByParticipant(
        address participant,
        string memory rewardId,
        uint256 nonce,
        bytes memory signature
    )
        external
        whenNotPaused
        nonReentrant
        onlyIfGivenSignatureIsValid(participant, rewardId, nonce, signature)
        onlyIfGivenSignatureIsUnused(signature)
        onlyIfContractHasEnoughcUSD
        onlyWhenAllParticipantsHaveNotBeenRewarded
        onlyIfSenderIsGivenParticipant(participant)
        onlyUnrewardedParticipant(participant)
        mustBeScreened(participant)
    {
        bool rewardTransferIsSuccesful = rewardParticipant(participant);

        if (rewardTransferIsSuccesful) {
            markSignatureAsHavingBeenUsed(signature, participant);
            markParticipantAsHavingClaimedReward(participant);
        }
    }

    /**
     * @dev Internal function to transfer the reward to a participant
     * @param participant - Address of the participant to reward
     * @return bool - True if the transfer was successful
     */
    function rewardParticipant(address participant) private returns (bool) {
        bool rewardTransferIsSuccesful = cUSD.transfer(
            participant,
            rewardAmountPerParticipantInWei
        );

        if (rewardTransferIsSuccesful) {
            unchecked {
                ++numberOfRewardedParticipants;
            }
            emit ParticipantRewarded(
                participant,
                rewardAmountPerParticipantInWei
            );
        }

        return rewardTransferIsSuccesful;
    }

    function markParticipantAsHavingClaimedReward(address participant) private {
        rewardedParticipants[participant] = true;

        unchecked {
            ++numberOfClaimedRewards;
        }
        emit ParticipantMarkedAsRewarded(participant);
    }

    function markSignatureAsHavingBeenUsed(
        bytes memory signature,
        address participant
    ) private {
        signaturesUsedForClaiming[signature] = true;

        unchecked {
            ++numberOfUsedSignatures;
        }
        emit SignatureUsed(signature, participant);
    }

    /**
     * @notice Allows the researcher to withdraw all remaining cUSD from the contract
     * @dev Can only be called by the contract owner when the contract is not paused
     */
    function withdrawAllRewardFundsToResearcher()
        external
        onlyOwner
        whenNotPaused
        onlyIfContractHasAnycUSD
    {
        uint256 balance = cUSD.balanceOf(address(this));
        bool transferIsSuccessful = cUSD.transfer(owner(), balance);

        if (transferIsSuccessful) {
            emit RewardFundsWithdrawn(owner(), balance);
        }
    }

    /**
     * @notice Updates the reward amount per participant
     * @dev Can only be called by the contract owner
     * @param _newRewardAmountPerParticipantInWei - New reward amount in wei
     */
    function updateRewardAmountPerParticipant(
        uint256 _newRewardAmountPerParticipantInWei
    ) external onlyOwner {
        require(
            _newRewardAmountPerParticipantInWei != 0,
            "Zero reward amount given"
        );

        uint256 oldRewardAmountPerParticipantInWei = rewardAmountPerParticipantInWei;

        uint256 newRewardAmountPerParticipantInWei = _newRewardAmountPerParticipantInWei;
        rewardAmountPerParticipantInWei = newRewardAmountPerParticipantInWei;

        emit RewardAmountUpdated(
            oldRewardAmountPerParticipantInWei,
            newRewardAmountPerParticipantInWei
        );
    }

    /**
     * @notice Updates the target number of participants for the survey
     * @dev Can only be called by the contract owner
     * @param _newTargetNumberOfParticipants - New target number of participants
     */
    function updateTargetNumberOfParticipants(
        uint256 _newTargetNumberOfParticipants
    ) external onlyOwner {
        require(
            _newTargetNumberOfParticipants != 0,
            "Zero number of target participants given"
        );

        uint256 oldTargetNumberOfParticipants = targetNumberOfParticipants;

        uint256 newTargetNumberOfParticipants = _newTargetNumberOfParticipants;

        targetNumberOfParticipants = newTargetNumberOfParticipants;

        emit TargetNumberOfParticipantsUpdated(
            oldTargetNumberOfParticipants,
            newTargetNumberOfParticipants
        );
    }

    /**
     * @notice Pauses all reward claims and withdrawals
     * @dev Can only be called by the contract owner
     */
    function pauseSurvey() external onlyOwner {
        _pause();
    }

    /**
     * @notice Resumes reward claims and withdrawals
     * @dev Can only be called by the contract owner
     */
    function unpauseSurvey() external onlyOwner {
        _unpause();
    }

    /**
     * @notice Checks if a participant has already claimed their reward
     * @param participant - Address of the participant to check
     * @return bool True if the participant has claimed their reward
     */
    function checkIfParticipantHasAlreadyClaimedReward(address participant)
        external
        view
        returns (bool)
    {
        return rewardedParticipants[participant];
    }

    function checkIfParticipantIsScreened(address participant)
        external
        view
        returns (bool)
    {
        return participantsScreenedForSurvey[participant];
    }

    function getRewardAmountPerParticipantInWei()
        external
        view
        returns (uint256)
    {
        return rewardAmountPerParticipantInWei;
    }

    function getNumberOfRewardedParticipants() external view returns (uint256) {
        return numberOfRewardedParticipants;
    }

    function getTargetNumberOfParticipants() external view returns (uint256) {
        return targetNumberOfParticipants;
    }

    function getNumberOfScreenedParticipants() external view returns (uint256) {
        return numberOfScreenedParticipants;
    }

    function getNumberOfUsedSignatures() external view returns (uint256) {
        return numberOfUsedSignatures;
    }

    function getNumberOfClaimedRewards() external view returns (uint256) {
        return numberOfClaimedRewards;
    }
}
